using System.Text;
using MarutiTrainingPortal.Models;
using MarutiTrainingPortal.Models.ViewModels;
using MarutiTrainingPortal.Repositories;
using MarutiTrainingPortal.Helpers;

namespace MarutiTrainingPortal.Services
{
    public class EventService : IEventService
    {
        private readonly IEventRepository _eventRepository;
        private readonly IFileUploadHelper _fileUploadHelper;

        public EventService(IEventRepository eventRepository, IFileUploadHelper fileUploadHelper)
        {
            _eventRepository = eventRepository;
            _fileUploadHelper = fileUploadHelper;
        }

        public async Task<(List<Event> Events, int TotalCount)> GetPagedEventsAsync(int page, int pageSize, string? searchQuery, string filter)
        {
            return await _eventRepository.GetPagedAsync(page, pageSize, searchQuery, filter);
        }

        public async Task<Event?> GetEventByIdAsync(int id)
        {
            return await _eventRepository.GetByIdAsync(id);
        }

        public async Task<Event> CreateEventAsync(EventViewModel model)
        {
            var eventItem = new Event
            {
                Title = model.Title,
                Summary = model.Summary,
                Description = model.Description,
                EventType = model.EventType,
                IsOnline = model.IsOnline,
                Location = model.Location,
                StartDateUtc = ConvertToUtc(model.StartDate, model.TimeZone),
                EndDateUtc = ConvertToUtc(model.EndDate, model.TimeZone),
                TimeZone = model.TimeZone,
                MaxCapacity = model.MaxCapacity,
                Status = model.Status,
                BannerUrl = await HandleBannerUploadAsync(model)
            };

            return await _eventRepository.AddAsync(eventItem);
        }

        public async Task<Event> UpdateEventAsync(EventViewModel model)
        {
            var existingEvent = await _eventRepository.GetByIdAsync(model.Id);
            if (existingEvent == null)
                throw new InvalidOperationException($"Event with ID {model.Id} not found");

            existingEvent.Title = model.Title;
            existingEvent.Summary = model.Summary;
            existingEvent.Description = model.Description;
            existingEvent.EventType = model.EventType;
            existingEvent.IsOnline = model.IsOnline;
            existingEvent.Location = model.Location;
            existingEvent.StartDateUtc = ConvertToUtc(model.StartDate, model.TimeZone);
            existingEvent.EndDateUtc = ConvertToUtc(model.EndDate, model.TimeZone);
            existingEvent.TimeZone = model.TimeZone;
            existingEvent.MaxCapacity = model.MaxCapacity;
            existingEvent.Status = model.Status;

            var newBannerUrl = await HandleBannerUploadAsync(model);
            if (!string.IsNullOrEmpty(newBannerUrl))
            {
                existingEvent.BannerUrl = newBannerUrl;
            }

            return await _eventRepository.UpdateAsync(existingEvent);
        }

        public async Task<bool> DeleteEventAsync(int id)
        {
            return await _eventRepository.SoftDeleteAsync(id);
        }

        public async Task<bool> ToggleStatusAsync(int id, string status)
        {
            var eventItem = await _eventRepository.GetByIdAsync(id);
            if (eventItem == null) return false;

            // Validate status transition
            var validStatuses = new[] { "Draft", "Upcoming", "Open", "Closed" };
            if (!validStatuses.Contains(status)) return false;

            eventItem.Status = status;
            await _eventRepository.UpdateAsync(eventItem);
            return true;
        }

        public async Task<List<EventRegistration>> GetRegistrationsAsync(int eventId)
        {
            return await _eventRepository.GetRegistrationsAsync(eventId);
        }

        public async Task<byte[]> ExportRegistrationsToCsvAsync(int eventId)
        {
            var eventItem = await _eventRepository.GetByIdAsync(eventId);
            var registrations = await _eventRepository.GetRegistrationsAsync(eventId);

            var sb = new StringBuilder();
            sb.AppendLine("Name,Email,Phone,RegisteredAt,EventTitle,Notes");

            foreach (var reg in registrations)
            {
                sb.AppendLine($"\"{reg.Name}\",\"{reg.Email}\",\"{reg.Phone ?? ""}\",\"{reg.RegisteredAt:O}\",\"{eventItem?.Title ?? ""}\",\"{reg.Notes ?? ""}\"");
            }

            return Encoding.UTF8.GetBytes(sb.ToString());
        }

        public async Task<bool> CanRegisterAsync(int eventId)
        {
            var eventItem = await _eventRepository.GetByIdAsync(eventId);
            if (eventItem == null || eventItem.IsDeleted) return false;
            if (eventItem.Status != "Open") return false;
            if (eventItem.IsFull) return false;

            return true;
        }

        public async Task<EventRegistration> RegisterUserAsync(int eventId, string name, string email, string? phone, string? notes)
        {
            if (!await CanRegisterAsync(eventId))
                throw new InvalidOperationException("Cannot register for this event");

            var eventItem = await _eventRepository.GetByIdAsync(eventId);
            if (eventItem!.MaxCapacity.HasValue && eventItem.CurrentRegistrations >= eventItem.MaxCapacity.Value)
                throw new InvalidOperationException("Event is full");

            var registration = new EventRegistration
            {
                EventId = eventId,
                Name = name,
                Email = email,
                Phone = phone,
                Notes = notes
            };

            await _eventRepository.AddRegistrationAsync(registration);
            await _eventRepository.IncrementRegistrationCountAsync(eventId);

            return registration;
        }

        public DateTime ConvertToUtc(DateTime localDateTime, string timeZoneId)
        {
            try
            {
                var timeZone = TimeZoneInfo.FindSystemTimeZoneById(timeZoneId);
                return TimeZoneInfo.ConvertTimeToUtc(localDateTime, timeZone);
            }
            catch
            {
                return DateTime.SpecifyKind(localDateTime, DateTimeKind.Utc);
            }
        }

        public DateTime ConvertFromUtc(DateTime utcDateTime, string timeZoneId)
        {
            try
            {
                var timeZone = TimeZoneInfo.FindSystemTimeZoneById(timeZoneId);
                return TimeZoneInfo.ConvertTimeFromUtc(utcDateTime, timeZone);
            }
            catch
            {
                return utcDateTime;
            }
        }

        private async Task<string?> HandleBannerUploadAsync(EventViewModel model)
        {
            if (model.BannerFile != null && model.BannerFile.Length > 0)
            {
                return await _fileUploadHelper.UploadEventBannerAsync(model.BannerFile);
            }

            return model.BannerUrl;
        }
    }
}
